// RegisterDerivative.jsx
import { client, nftCollectionAddress } from "../utils/utils.js";
import { uploadJSONToIPFS } from "../utils/uploadToIpfs.ts";
import { useState, useEffect } from "react";
import { useActiveAccount } from "thirdweb/react";
import { WIP_TOKEN_ADDRESS } from "@story-protocol/core-sdk";
import { createHash } from "crypto";
const RegisterDerivative = ({ parentIpId, ipfsImageUrl, onComplete }) => {
  const account = useActiveAccount();
  const [derivativeIPId, setDerivativeIPId] = useState();

  const createLicenseandDerivative = async () => {
    try {
      const derivData = {
        parentIpIds: [parentIpId],
        licenseTermsIds: [95],
        maxMintingFee: BigInt(0),
        maxRts: 100_000_000,
        maxRevenueShare: 100,
      };

      const ipMetadata = client.ipAsset.generateIpMetadata({
        title: `Derivative Meme from parent IP:${parentIpId}`,
        description: "Derivative Meme",
        ipType: "image",
        attributes: [
          {
            key: "Model",
            value: "dall-e-2",
          },
        ],
        creators: [
          {
            name: `Derivative Meme generated by ${account.address}`,
            contributionPercent: 100,
            address: account.address,
          },
        ],
        media: [
          {
            name: "Derivative Meme",
            url: ipfsImageUrl,
            mimeType: "image/png",
          },
        ],
      });

      const nftMetadata = {
        name: "Meme Derivative Ownership NFT",
        description: `This NFT represents ownership of the Meme Derivative received by ${account.address}`,
        image: ipfsImageUrl,
        attributes: [
          {
            key: "Model",
            value: "dall-e-2",
          },
        ],
      };

      const ipIpfsHash = await uploadJSONToIPFS(ipMetadata);
      const ipHash = createHash("sha256")
        .update(JSON.stringify(ipMetadata))
        .digest("hex");
      const nftIpfsHash = await uploadJSONToIPFS(nftMetadata);
      const nftHash = createHash("sha256")
        .update(JSON.stringify(nftMetadata))
        .digest("hex");

      const response = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({
        spgNftContract: nftCollectionAddress,
        derivData,
        allowDuplicates: true,
        ipMetadata: {
          ipMetadataURI: `https://ipfs.io/ipfs/${ipIpfsHash}`,
          ipMetadataHash: `0x${ipHash}`,
          nftMetadataURI: `https://ipfs.io/ipfs/${nftIpfsHash}`,
          nftMetadataHash: `0x${nftHash}`,
        },
        txOptions: { waitForTransaction: true },
      });

      console.log(
        `Completed at transaction hash ${response.txHash}, IPA ID: ${response.ipId}, Token ID: ${response.tokenId}`
      );
      setDerivativeIPId(response.ipId);
      await payIP(response.ipId);
      onComplete();
    } catch (error) {
      console.error("Error creating derivative:", error);
    }
  };

  const payIP = async (derivativeId) => {
    try {
      const payRoyalty = await client.royalty.payRoyaltyOnBehalf({
        receiverIpId: parentIpId,
        payerIpId: derivativeId,
        token: WIP_TOKEN_ADDRESS,
        amount: 1,
        txOptions: { waitForTransaction: true },
      });
      console.log(`Paid royalty at transaction hash ${payRoyalty.txHash}`);
    } catch (error) {
      console.error("Error paying royalty:", error);
    }
  };

  useEffect(() => {
    createLicenseandDerivative();
  }, []);

  return (
    <div className="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50">
      <div className="bg-white p-6 rounded-lg shadow-xl">
        <p className="text-lg">Processing your derivative license...</p>
      </div>
    </div>
  );
};

export default RegisterDerivative;
