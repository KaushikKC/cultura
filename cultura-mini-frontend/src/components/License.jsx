// RegisterDerivative.jsx
import { client, nftCollectionAddress } from "../utils/utils.js";
import { uploadJSONToIPFS } from "../utils/uploadToIpfs.ts";
import { useState, useEffect } from "react";
import { useActiveAccount } from "thirdweb/react";
import { WIP_TOKEN_ADDRESS } from "@story-protocol/core-sdk";
import { createHash } from "crypto";
const RegisterDerivative = ({ parentIpId, ipfsImageUrl, onComplete }) => {
  const account = useActiveAccount();
  const [status, setStatus] = useState("Creating derivative...");

  const createLicenseandDerivative = async () => {
    try {
      setStatus("Initializing derivative creation...");
      const derivData = {
        parentIpIds: [parentIpId],
        licenseTermsIds: [95],
        maxMintingFee: BigInt(0),
        maxRts: 100_000_000,
        maxRevenueShare: 100,
      };

      setStatus("Generating metadata...");

      const ipMetadata = client.ipAsset.generateIpMetadata({
        title: `Derivative Meme from parent IP:${parentIpId}`,
        description: "Derivative Meme",
        ipType: "image",
        attributes: [
          {
            key: "Model",
            value: "dall-e-2",
          },
        ],
        creators: [
          {
            name: `Derivative Meme generated by ${account.address}`,
            contributionPercent: 100,
            address: account.address,
          },
        ],
        media: [
          {
            name: "Derivative Meme",
            url: ipfsImageUrl,
            mimeType: "image/png",
          },
        ],
      });

      const nftMetadata = {
        name: "Meme Derivative Ownership NFT",
        description: `This NFT represents ownership of the Meme Derivative received by ${account.address}`,
        image: ipfsImageUrl,
        attributes: [
          {
            key: "Model",
            value: "dall-e-2",
          },
        ],
      };

      const ipIpfsHash = await uploadJSONToIPFS(ipMetadata);
      const ipHash = createHash("sha256")
        .update(JSON.stringify(ipMetadata))
        .digest("hex");
      const nftIpfsHash = await uploadJSONToIPFS(nftMetadata);
      const nftHash = createHash("sha256")
        .update(JSON.stringify(nftMetadata))
        .digest("hex");

      setStatus("Creating derivative...");

      const response = await client.ipAsset.mintAndRegisterIpAndMakeDerivative({
        spgNftContract: nftCollectionAddress,
        derivData,
        allowDuplicates: true,
        ipMetadata: {
          ipMetadataURI: `https://ipfs.io/ipfs/${ipIpfsHash}`,
          ipMetadataHash: `0x${ipHash}`,
          nftMetadataURI: `https://ipfs.io/ipfs/${nftIpfsHash}`,
          nftMetadataHash: `0x${nftHash}`,
        },
        txOptions: { waitForTransaction: true },
      });

      setStatus("Processing royalty payment...");
      const payRoyalty = await client.royalty.payRoyaltyOnBehalf({
        receiverIpId: parentIpId,
        payerIpId: response.ipId,
        token: WIP_TOKEN_ADDRESS,
        amount: 0.03,
        txOptions: { waitForTransaction: true },
      });

      onComplete({
        derivativeTxHash: response.txHash,
        ipId: response.ipId,
        tokenId: response.tokenId,
        royaltyTxHash: payRoyalty.txHash,
      });

      console.log(
        `Completed at transaction hash ${response.txHash}, IPA ID: ${response.ipId}, Token ID: ${response.tokenId}`
      );
    } catch (error) {
      console.error("Error creating derivative:", error);
      setStatus("Error occurred. Please try again.");
    }
  };

  // const payIP = async (derivativeId) => {
  //   try {
  //     const payRoyalty = await client.royalty.payRoyaltyOnBehalf({
  //       receiverIpId: parentIpId,
  //       payerIpId: derivativeId,
  //       token: WIP_TOKEN_ADDRESS,
  //       amount: 1,
  //       txOptions: { waitForTransaction: true },
  //     });
  //     console.log(`Paid royalty at transaction hash ${payRoyalty.txHash}`);
  //   } catch (error) {
  //     console.error("Error paying royalty:", error);
  //   }
  // };

  useEffect(() => {
    createLicenseandDerivative();
  }, []);

  return (
    <div className="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50">
      <div className="bg-white p-8 rounded-lg shadow-xl text-center">
        <div className="animate-spin rounded-full h-10 w-10 border-b-2 border-[#3E2723] mx-auto mb-4"></div>
        <p className="text-lg text-[#3E2723]">{status}</p>
      </div>
    </div>
  );
};

export default RegisterDerivative;
